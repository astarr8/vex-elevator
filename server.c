#pragma config(Sensor, in1,    callF5,         sensorAnalog)
#pragma config(Sensor, in2,    callF6,         sensorAnalog)
#pragma config(Sensor, in3,    inLiftCall,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  ledF0,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  ledF1,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  ledF2,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  ledF3,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  ledF4,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  ledF5,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  ledF6,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  callF0,         sensorTouch)
#pragma config(Sensor, dgtl9,  callF1,         sensorTouch)
#pragma config(Sensor, dgtl10, callF2,         sensorTouch)
#pragma config(Sensor, dgtl11, callF3,         sensorTouch)
#pragma config(Sensor, dgtl12, callF4,         sensorTouch)
#pragma config(Motor,  port2,           liftMotor,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NUMBER_OF_FLOORS 7
#define LED_MOVING_DURATION 700
#define setLED(x, y) do { leds[x].state = y; } while(0);

typedef struct
{
	int sensorAddress;
	int state;
	int startTime;
} led;

led leds[NUMBER_OF_FLOORS];

task ledStateTask()
{
	while(true)
	{
		bool noneWaiting = true;
		for(int i = 0; i < NUMBER_OF_FLOORS; i++)
		{
			//Switch Case
		  //0: Off
		  //1: On
		  //2+3: Blink at Normal Move Speed
			switch(leds[i].state)
			{
				case 0:
					SensorValue[leds[i].sensorAddress] = 0;
					leds[i].startTime = -1;
					break;
				case 1:
					SensorValue[leds[i].sensorAddress] = 1;
					leds[i].startTime = -1;
					break;
				case 2: //Turn on LED
				  leds[i].state = 3;
					leds[i].startTime = time1[T1];
					SensorValue[leds[i].sensorAddress] = 1;
			    break;
			  case 3: //Continue blink loop
			    if ((time1[T1] - leds[i].startTime) >= LED_MOVING_DURATION)
			    {
			     	SensorValue[leds[i].sensorAddress] = !SensorValue[leds[i].sensorAddress];
			   		leds[i].startTime = time1[T1];
			   	}
			   	break;
			}
			if(leds[i].startTime != -1)
				noneWaiting = false;
		}
		if(noneWaiting)
			clearTimer(T1);
	}
}
task main()
{
	//Initialize led addresses
	leds[0].sensorAddress = ledF0;
	leds[1].sensorAddress = ledF1;
	leds[2].sensorAddress = ledF2;
	leds[3].sensorAddress = ledF3;
	leds[4].sensorAddress = ledF4;
	leds[5].sensorAddress = ledF5;
	leds[6].sensorAddress = ledF6;
	startTask(ledStateTask);

	leds[1].state = 2;
}
